
# 用一個陣列實作的動態排序容器

> 去年出 [ICPC 2021 台北站](https://icpc2021.ntub.edu.tw/) 的 [題目](https://drive.google.com/file/d/1YUMxajkblszqjcVhb3ksvv1UL44JOlJT/view) ([codeforces](https://codeforces.com/gym/103443/))，在驗題時想了一個資料結構。

這個資料結構是動態排序的容器，是用一個 array 實作的。它的時間複雜度比常見的 balanced binary search tree 要差一點，不過它把所有的資料緊密地排在連續的記憶體，不需要額外的指標，memory locality 比較好。並且如果需要使用 gdb 的時候，直接用眼睛看這一串連續的記憶體就可以知道有沒有問題，不用 trace 指標。

以下是這個容器各操作的時間複雜度 (假設容器內容物的數量為 <katex>N</katex>)：

 + insert 的時間複雜度是 amortized <katex>O(lgN)</katex>，單次的 worst case 是 <katex>O(N)</katex>
 + query 一個 value 是否存在、或是不存在時輸出前後最相近項的時間複雜度是 <katex>O(lg^2N)</katex>
 + query 一個 value 在這容器裡排序第幾大的時間複雜度也是 <katex>O(lg^2N)</katex> (這個是 red-black tree 不能作的操作，不過 size-balanced tree 可以)
 + delete 一個指定 value 的元素是 <katex>O(lg^2N)</katex>

## 實作

### 靜態結構

從最左邊開始，湊滿盡量大的 2 的冪次為一段，剩餘的部分也是盡量湊滿 2 的冪次為一段，一直切到吃光整個 array。這樣把整個 array 切成若干小段，每一個小段裡分別都是排序好的元素。這樣的小段，最多會有 <katex>O(lgN)</katex> 個。

以下是容器裡存了 7 個元素的例子：

<canvas data-array=1,3,7,9,,5,6,,8>

以長度 7 為例就是拆成 3 個小段：4個、2個、1個。

### query

query 一個 value 是否存在的方法，或如果不存在的時候要找最相近的一個出來，就是在這每一個小段裡分別作一次 binary search。所以花的總時間 worst case 是
<katex>O(lg\frac{N}{2} + lg\frac{N}{4} + ... + lg1) = O(lg^2N)</katex>

query 一個 value 在這容器資料裡可以排第幾大，也是在每一個小段作 binary search，就可以找出在每一個小段裡，比這個 value 小的元素有幾個，把它們通通加起來就是整個容器裡比 value 小的元素有幾個，那就是 value 在這容器的排名。花的時間和上面是一樣的。

### insert

新增一個 value 進去的時候，先把它放在 array 的末端。接下來看它會補滿多少層 2 的乘冪，每一層作一次 merge sort 的 merge。
前面舉例長度 7 的容器如果 insert 一個 5，就會是下面這樣的過程：

<canvas data-array=1,3,7,9,,5,6,,8,,5>

<canvas data-array=1,3,7,9,,5,6,,5,8>

<canvas data-array=1,3,7,9,,5,5,6,8>

<canvas data-array=1,3,5,5,6,7,8,9>

worst case 會作 <katex>O(lgN)</katex> 次 merge，不過 merge 的長度是 2、4、8、16… 這全部加起來最多是 <katex>2N</katex>，所以單次 insert 的 worst case 是 <katex>O(N)</katex>。

而若考慮所有的 insert 的總耗時，分開考慮 merge 操作時的小段長度：每 insert 2 次會作到一次長度 2 的小段 merge；每 insert 4 次會作到一個長度 4 的小段 merge；依此類推。
在 insert <katex>N</katex> 次之後會作 <katex>N</katex> 次長度 1 的小段 merge、<katex>\frac{N}{2}</katex> 次長度 2 的小段 merge、<katex>\frac{N}{4}</katex> 次長度 4 的小段 merge、…，每一種長度的 merge 都剛好用掉 <katex>O(N)</katex> 的時間。而總共會有 <katex>lgN</katex> 種長度，所以總耗時是 <katex>O(NlgN)</katex>，單次平均耗時是 <katex>O(lgN)</katex>，也就是 amortized <katex>O(lgN)</katex>。

merge 的時候，最多會額外使用 <katex>\frac{N}{2}</katex> 格記憶體 (先把左小段複製到額外的記憶體，然後從左小段開始填入右小段與額外記憶體的 merge)。如果預期這個容器會持續長大，可以考慮讓額外的記憶體就是整個容器最右邊的延伸，爾後就漸漸成為存放新元素的空間不需要歸還了。如果想節省掉額外的記憶體，可以考慮換成時間複雜度多乘一個 <katex>O(lgN)</katex> 的 quick sort 或 heap sort、或找其他宣稱 inplace merge sort 的方法來代替，作為空間成本與時間成本之間的取捨。

### delete

如果不需要 delete 的話，上述的資料結構實作起來非常簡單，加進 delete 之後就會複雜不少，而使用情境倒是常有不需要 delete 的時候。

delete 的實作，原則就是先標註要刪除的元素留著一個洞，等之後 merge 的範圍含括到它的時候再把這個洞移到 merge 範圍的最右邊 (就是整個 array 的最右邊) 並縮短容器的大小。如果 merge 時在某一層發生了移洞縮短，那麼這一輪就一定不會再往更上一層 merge。這個原則還算單純。

不過如果只是把要刪除的位置標註起來，而不巧遇到的操作順序會造成好多個洞連續排在一起沒有被 merge 清除，更不巧的是 query 最相近元素時 value 剛好落在這一串連續洞的範圍裡，那麼要去找到最接近的元素也就是連續洞的邊緣，就有可能會花到 <katex>O(N)</katex> 的時間。所以需要額外作一些註記，以便 query 落在連續洞的時候，可以很快知道岸邊在哪裡，並且這個註記的動作也不能太花時間，像是如果要在連續洞裡每個位置都去更新邊緣的距離會花到 <katex>O(N)</katex> 的時間也不可以。這個額外的註記方法會有一點複雜。
